<?php
/**
  * <h3>GloryLands Debug System</h3>
  *
  * The debug system is used to handle and archive internal errors. This also hides
  * the error from the end-user and notifies the administrators
  *
  * @package GloryLands
  * @subpackage Engine
  * @author John Haralampidis <johnys2@gmail.com>
  * @copyright Copyright (C) 2007-2008, John Haralampidis
  * @version 1.0
  */
  
/**
  * Error level definitions
  */
define(ERR_MESSAGE, 0);
define(ERR_INFO, 1);
define(ERR_NOTICE, 2);
define(ERR_ERROR, 3);
define(ERR_WARNING, 4);
define(ERR_CRITICAL, 8);

/**
  * Store a debug message on the debug queue
  *
  * This queue is stored on the user session and  can be retrived 
  * on the first visual representation of the error or the first debug request.
  *
  * @param array $description	The debug text to hold on the buffer
  * @param array $level			The debug message level (ex. ERR_
  */
function debug_message($description, $level=ERR_MESSAGE) {
	debug_store_error(array(
		'trace' => debug_backtrace(),
		'level' => $level,
		'description' => $description
	));
}

/**
  * Store an error on the debug queue
  *
  * This queue is stored on the user session and  can be retrived 
  * on the first visual representation of the error or the first debug request.
  *
  * @param array $errinfo		The error info structure as generated in the debug_error function
  */
function debug_store_error($errinfo) {
	// Set-up session
	if (!isset($_SESSION[DATA]['errors'])) $_SESSION[DATA]['errors']=array();
	
	// Hold some misc information on errinfo
	$errinfo['timestamp'] = time();
	
	// Store the new information
	$_SESSION[DATA]['errors'][] = $errinfo;
}

/** 
  * Visualize function parameters
  *
  * Converts backtrace parameter array into a sequential variables just as passed on function call
  *
  * @param array $backargs		The backtrace parameters array to visualize
  * @return string				Returns the HTML representation of the backtrace
  */
function debug_render_args($backargs) {
	$html='';
	foreach ($backargs as $arg) {
		if ($html!='') $html.=', ';
		if (is_string($arg)) {
			$html.='"'.$arg.'"';
		} elseif (is_object($arg)) {
			$html.='<'.print_r($arg,true).'>';
		} elseif (is_array($arg)) {
			$html.='[<span title="'.str_replace("\n"," ",print_r($arg,true)).'"><em>Array</em></span>]';
		} else {
			$html.=$arg;
		}
	}
	return $html;
}

/** 
  * Visualize a backtrace
  *
  * Visualizes in HTML format the debug backtrace
  *
  * @param array $backtrace		The backtrace array to visualize
  * @return string				Returns the HTML representation of the backtrace
  */
function debug_render_backtrace($backtrace) {
	$html = '';
	array_shift($backtrace); /* The first entry is the debug_error function */
	foreach ($backtrace as $index => $trace) {
		$base = $trace['type'];
		if ($base!='') $base=$trace['class'].$base;
		$html .= '<b>&bull; '.(sizeof($backtrace)-$index).'</b> '.$base.$trace['function'];
		if (isset($trace['args'])) {
			$html.='('.htmlspecialchars(debug_render_args($trace['args'])).')';
		} else {
			$html.='()';
		}
		$html.=' on <b>'.$trace['file'].'('.$trace['line'].')</b><br />'."\n";
	}
	return $html;
}

/**
  * Visualize an error debug stack in HTML format 
  *
  * This function reads the error stack (generated by debug_store_error function calls)
  * and genrates an HTML, visual representation of the debug stack.
  * It returns the HTML stack
  *
  * @return string				Returns the HTML representation of the error stack
  */
function debug_render_errors() {
	// Check for valid error stack
	if (!isset($_SESSION[DATA]['errors'])) {
		return '';
	}
	
	// Start HTML design
	$html = '
	<style type="text/css">
	<!--
	div.debug_window {
		font-size: 12px; 
		border: dashed 2px #999999; 
		background-color:#F0F0F0; 
		color: #333333; 
		font-family: Arial, Helvetica, sans-serif;
	}
	div.debug_window div.head {
		font-size: 10px; 
		font-weight: bold; 
		color: #FFFFFF; 
		background-color:#666666
	}
	div.debug_window div.expand {
		height: 14px;
		overflow: hidden;
		color: #333333; 
		padding: 1px;
	}
	div.debug_window div.expand:hover {
		background-color: #FFFFFF;
		border: solid 1px #666666;
		padding: 0px;
		height: inherit;
		color: #333333; 
		overflow: visible;
	}
	-->
	</style>
	<div class="debug_window"><div class="head">GloryLands Debug Console</div><table border="1" style="color: #000000; font-size: 10px;"><tr><th width="40">Time</th><th width="40">Level</th><th width="500">Backtrace</th><th>Message</th></tr>
	';
	
	// Level-Name mapping
	$levelname = array(
		ERR_MESSAGE => '<font color="#666666">MESSAGE</font>',
		ERR_INFO => '<font color="#009900">INFO</font>',
		ERR_NOTICE => '<font color="#000099">NOTICE</font>',
		ERR_WARNING => '<font color="#FF6600">WARNING</font>',
		ERR_ERROR => '<font color="red">ERROR</font>',
		ERR_CRITICAL => '<font color="red"><b>CRITICAL</b></font>'
	);
	
	// Loop on the stacked messages
	foreach ($_SESSION[DATA]['errors'] as $error) {
		$html .= '<tr><td>'.date('H:i:s', $error['timestamp']).'</td>';
		$html .= '<td>'.$levelname[$error['level']].'</td>';
		$html .= '<td>'.debug_render_backtrace($error['trace']).'</td>';
		$html .= '<td valign="top"><pre style="font-size: 10px; padding: 0px; margin: 0px;">'.htmlspecialchars($error['description']).'</pre></td>';
		$html .= '</tr>'."\n";
	}
	
	// Finalize HTML design and return result
	$html.= '</table></div>';
	return $html;
}

/**
  * Handle an error by the debug system
  *  
  * This function handles internal errors. Depending on the situation, it either hides the error
  * from the user and continues the normal execution, or breaks the execution and
  * displays an error message. 
  *
  * @param string $description 	The error description
  * @param int $level			The error level. If the error is ERR_CRITICAL, this function will halt further execution.
  * @return array|bool 			Returns the data chunk in an array format or false if an error occured
  *
  */
function debug_error($description, $level=ERR_ERROR) {
	global $act_result, $outmode;
	$critical = ($level == ERR_CRITICAL);
	
	// Construct the debug information
	$errinfo = array(
		'trace' => debug_backtrace(),
		'level' => $level,
		'description' => $description
	);
	
	// Log the error
	debug_store_error($errinfo);
	
	// Prepare the message that will be sent to the client
	$html_message = '';
	
	// Find out in which way we should render the error message:

	// We are inside a process execution. 
	// The format of the data being sent to the browser depends on the output mode selected
	if (defined('IN_PROCESS')) {
		$err_show = true;
		$err_show_mode = strtoupper($outmode);
	
	// We are inside a message feeding utility
	// The format of the data being sent is always JSON
	} elseif (defined('IN_MSGFEED')) {
		$err_show = true;
		$err_show_mode = 'JSON';
	
	// We have no active stream 
	// We should not display anything
	} else {
		$err_show = false;
	}		

	// If the error is critical, break execution
	if ($critical) die();
}
  
?>